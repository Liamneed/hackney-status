<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Active Hackneys ‚Äî Callsign ¬∑ Plate ¬∑ Reg ¬∑ Status</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <link rel="stylesheet" href="hackney.css" />

  <style>
    .status-text {
      font-weight: 600;
      font-size: 0.9rem;
      white-space: nowrap;
    }
    .status-text--notworking { color: #dc2626; }      /* red */
    .status-text--clear      { color: #16a34a; }      /* green */
    .status-text--dispatched { color: #e28d00 }       /* orange */
    .status-text--dispatched-acc { color: #ff1493; }  /* purple */
    .status-text--pickedup-cash { color: #e28d00 }    /* orange */
    .status-text--pickedup-acc  { color: #ff1493; }   /* purple */
    .status-text--rank      { color: #009dd2 }        /* blue */
    .status-text--offering  {
      color: #f9fafb;
      text-shadow: 0 0 3px rgba(0,0,0,0.9);
    }
    .status-text--busy      { color: #fbbf24; }       /* generic busy */
    .status-text--unknown   { color: #6b7280; }       /* grey */

    .cell-status { text-align: right; }
    @media (max-width: 640px) {
      .cell-status { text-align: left; }
    }
  </style>
</head>
<body>
  <header id="appHeader" class="header">
    <div class="header-inner">
      <div class="brand-box">N</div>
      <div class="header-title-wrap">
        <h1 class="header-title">Active Hackney Drivers</h1>
        <p class="header-subtitle">
          Live view of licensed Hackney carriages. Search by callsign, taxi plate or reg and use A+/A‚àí to adjust text size on smaller screens.
        </p>
      </div>
      <div class="header-actions">
        <div class="font-buttons">
          <button id="fontSm" class="btn-ghost" title="Smaller text">A‚àí</button>
          <button id="fontLg" class="btn-ghost" title="Larger text">A+</button>
        </div>
        <button id="refreshBtn" class="btn-outline" title="Refresh list and statuses">Refresh</button>
      </div>
    </div>

    <div class="header-controls">
      <div class="controls-row">
        <div class="search-box">
          <span class="search-icon">üîç</span>
          <input id="searchInput" type="search" inputmode="search"
                 placeholder="Search callsign, taxi plate or reg‚Ä¶"
                 class="search-input" />
        </div>

        <select id="statusFilter" class="control-select">
          <option value="all">Show: All drivers</option>
          <option value="online">Working only</option>
          <option value="offline">Offline only</option>
        </select>

        <select id="sortSelect" class="control-select">
          <option value="callsign">Sort: Callsign</option>
          <option value="plateNumber">Sort: Taxi Plate</option>
          <option value="registration">Sort: Reg Plate</option>
        </select>

        <label class="control-label">Row highlight</label>
        <select id="hlSelect" class="control-select">
          <option value="none">None</option>
          <option value="border">Border</option>
          <option value="background" selected>Background</option>
        </select>
      </div>

      <div id="statusCounts" class="status-counts"></div>

      <div class="status-legend">
        <span class="legend-item">
          <span class="legend-swatch legend-swatch--clear"></span>Clear / available
        </span>
        <span class="legend-item">
          <span class="legend-swatch legend-swatch--dispatched"></span>Dispatched to pick up
        </span>
        <span class="legend-item">
          <span class="legend-swatch legend-swatch--pickedup"></span>Passenger on board
        </span>
        <span class="legend-item">
          <span class="legend-swatch legend-swatch--rank"></span>Rank job in progress
        </span>
        <span class="legend-item">
          <span class="legend-swatch legend-swatch--notworking"></span>Offline / off shift
        </span>
      </div>

      <div id="colHeader" class="table-header-wrap">
        <div class="table-row table-header">
          <div>Callsign</div>
          <div>Status</div>
          <div>Reg Plate</div>
          <div>Taxi Plate</div>
        </div>
      </div>
    </div>
  </header>

  <main class="main">
    <section class="card">
      <div id="rows" aria-live="polite"></div>
      <div id="skeleton" class="skeleton">
        <div class="skeleton-row"></div>
        <div class="skeleton-row"></div>
        <div class="skeleton-row"></div>
      </div>
    </section>
  </main>

  <script>
    const MIN_PX = 15, MAX_PX = 20, ROOT_KEY = "root-font-px";
    const applyRootPx = (px) => document.documentElement.style.fontSize = px + "px";
    let rootPx = Math.min(MAX_PX, Math.max(MIN_PX, Number(localStorage.getItem(ROOT_KEY) || 16)));
    applyRootPx(rootPx);
    document.getElementById("fontSm").addEventListener("click", () => {
      rootPx = Math.max(MIN_PX, rootPx - 1);
      applyRootPx(rootPx);
      localStorage.setItem(ROOT_KEY, rootPx);
      adjustStickyOffset();
    });
    document.getElementById("fontLg").addEventListener("click", () => {
      rootPx = Math.min(MAX_PX, rootPx + 1);
      applyRootPx(rootPx);
      localStorage.setItem(ROOT_KEY, rootPx);
      adjustStickyOffset();
    });

    function adjustStickyOffset(){
      const h = document.getElementById("appHeader")?.offsetHeight || 60;
      const ch = document.getElementById("colHeader");
      if (ch) ch.style.top = h + "px";
    }
    window.addEventListener("resize", adjustStickyOffset);
    document.addEventListener("DOMContentLoaded", adjustStickyOffset);

    const API_VEHICLES = "/api/vehicles";
    const ONLINE_URL   = "/api/status";
    const SSE_URL      = "/api/status/stream";
    const VEHICLE_REFRESH_MS = 60000;
    const STATUS_REFRESH_MS  = 5000;
    const SHOW_ALL = new URL(location.href).searchParams.get("all") === "1";

    const HL_KEY = "row-highlight-mode";
    const hlSelect = document.getElementById("hlSelect");
    let highlightMode = localStorage.getItem(HL_KEY) || "background";
    hlSelect.value = highlightMode;
    hlSelect.addEventListener("change", () => {
      highlightMode = hlSelect.value;
      localStorage.setItem(HL_KEY, highlightMode);
      render();
    });

    const getList = (data) =>
      Array.isArray(data) ? data :
      (data?.items || data?.results || data?.vehicles || data?.data || []);

    const getCallsign = (v) => v?.callsign ?? v?.callSign ?? v?.code ?? v?.mdtId ?? v?.mdtID ?? "";
    const getPlate    = (v) => v?.plateNumber ?? v?.plate ?? v?.registrationNumber ?? "";
    const getReg      = (v) => v?.registration ?? v?.vrm ?? v?.reg ?? "";
    const normKey     = (s) => String(s || "").trim().toUpperCase();
    const toNum       = (s) => { const n = Number(String(s).trim()); return Number.isFinite(n) ? n : null; };

    const isActive = (v) => {
      if (typeof v?.isActive === "boolean") return v.isActive;
      if (typeof v?.active === "boolean") return v.active;
      if (typeof v?.isArchived === "boolean") return !v.isArchived;
      if (typeof v?.archived === "boolean") return !v.archived;
      return true;
    };

    const hasHackneyCapability = (v) => {
      if (SHOW_ALL) return true;
      if (Array.isArray(v?.capabilityIds)) return v.capabilityIds.includes(14);
      if (Array.isArray(v?.capabilities)) {
        return v.capabilities.some(c => {
          if (typeof c === "number") return c === 14;
          if (typeof c === "string") return c === "14" || c.toLowerCase().includes("hackney");
          if (c && typeof c === "object") return c.id === 14 || (c.name && String(c.name).toLowerCase().includes("hackney"));
          return false;
        });
      }
      if (typeof v?.capability === "number") return v.capability === 14;
      if (typeof v?.capability === "string") return v.capability?.toLowerCase?.().includes("hackney") || v.capability === "14";
      return false;
    };

    const compare = (a, b, field) => {
      const A = String(field(a) ?? ""); const B = String(field(b) ?? "");
      const na = toNum(A), nb = toNum(B);
      if (na !== null && nb !== null) return na - nb;
      return A.localeCompare(B, undefined, { numeric: true, sensitivity: "base" });
    };

    const rowsEl     = document.getElementById("rows");
    const skeletonEl = document.getElementById("skeleton");
    const refreshBtn = document.getElementById("refreshBtn");
    const searchEl   = document.getElementById("searchInput");
    const sortEl     = document.getElementById("sortSelect");
    const statusFilterEl = document.getElementById("statusFilter");
    const statusCountsEl = document.getElementById("statusCounts");

    let baseMaster = [];
    let master = [];
    let onlineMap = new Map();
    let statusPollTimer = null;

    function extractCallsign(obj) {
      const direct = obj?.callsign ?? obj?.callSign ?? obj?.code ?? obj?.mdtId ?? obj?.mdtID ?? obj?.vehicleCode ?? obj?.driverCode ?? null;
      if (direct) return direct;
      const d = obj?.Driver || obj?.driver || {};
      const v = obj?.Vehicle || obj?.vehicle || {};
      return d?.Callsign ?? d?.callsign ?? d?.callSign ?? v?.Callsign ?? v?.callsign ?? v?.callSign ?? null;
    }

    function extractDriverStatusLabel(obj) {
      const raw =
        obj?.driverStatus ??
        obj?.driverStatusLabel ??
        obj?.statusText ??
        obj?.stateText ??
        obj?.driver_state ??
        obj?.status ??
        obj?.availability ??
        "";
      return String(raw || "").trim();
    }

    // Build map purely from server data
    function buildOnlineMap(data) {
      const list = getList(data);
      const map = new Map();
      for (const item of list) {
        const cs = item?.callsign ?? extractCallsign(item);
        if (!cs) continue;

        const key = normKey(cs);
        const online = (typeof item?.online === "boolean") ? item.online : false;
        const dsLabel = extractDriverStatusLabel(item);
        const dsCode  = item?.driverStatusCode || null;

        let label = dsLabel;
        let code  = dsCode;

        if (!online && !label && !code) {
          label = "OFFLINE";
          code  = "NotWorking";
        }

        map.set(key, {
          online,
          updatedAt: item?.updatedAt || item?.timestamp || item?.time || item?.ModifiedDate || null,
          driverStatusLabel: label || null,
          driverStatusCode: code || null,
        });
      }
      return map;
    }

    // üîç Online detection: trust status code/label first, then .online flag
    const onlineFor = (cs) => {
      const rec = onlineMap.get(normKey(cs));
      if (!rec) return false;

      const code = (rec.driverStatusCode || "").toString().trim();
      const label = (rec.driverStatusLabel || "").toString().trim().toUpperCase();

      // Definitely offline
      if (code === "NotWorking" || label === "OFFLINE") return false;

      // These codes/labels mean "working"
      const workingCodes = [
        "Clear",
        "BusyMeterOff",
        "BusyMeterOffAccount",
        "BusyMeterOnFromMeterOffCash",
        "BusyMeterOnFromMeterOffAccount",
        "BusyMeterOnFromClear",
        "JobOffered",
      ];
      const workingLabels = [
        "CLEAR",
        "DISPATCH",
        "DISPATCH ACC",
        "BUSY",
        "BUSY CASH",
        "BUSY ACC",
        "RANK",
        "OFFER",
      ];

      if (workingCodes.includes(code)) return true;
      if (workingLabels.includes(label)) return true;

      // Fallback to backend .online flag
      return !!rec.online;
    };

    const updatedFor      = (cs) => onlineMap.get(normKey(cs))?.updatedAt || null;
    const driverStatusLabelFor = (cs) => onlineMap.get(normKey(cs))?.driverStatusLabel || null;
    const driverStatusCodeFor  = (cs) => onlineMap.get(normKey(cs))?.driverStatusCode || null;

    // Short, descriptive status labels
    function mapDriverStatus(rawCode, rawLabel) {
      const code = (rawCode || "").toString().trim();
      const label = (rawLabel || "").toString().trim();
      const lowerLabel = label.toLowerCase();

      if (code === "NotWorking") {
        return { text: "OFFLINE", cls: "status-text--notworking" };
      }
      if (code === "Clear") {
        return { text: "CLEAR", cls: "status-text--clear" };
      }
      if (code === "BusyMeterOff") {
        return { text: "DISPATCH", cls: "status-text--dispatched" };
      }
      if (code === "BusyMeterOffAccount") {
        return { text: "DISPATCH ACC", cls: "status-text--dispatched-acc" };
      }
      if (code === "BusyMeterOnFromMeterOffCash") {
        return { text: "BUSY CASH", cls: "status-text--pickedup-cash" };
      }
      if (code === "BusyMeterOnFromMeterOffAccount") {
        return { text: "BUSY ACC", cls: "status-text--pickedup-acc" };
      }
      if (code === "BusyMeterOnFromClear") {
        return { text: "RANK", cls: "status-text--rank" };
      }
      if (code === "JobOffered") {
        return { text: "OFFER", cls: "status-text--offering" };
      }

      if (!code) {
        if (
          lowerLabel.includes("off shift") ||
          lowerLabel.includes("off duty") ||
          lowerLabel.includes("logged off") ||
          lowerLabel.includes("signed off") ||
          lowerLabel.includes("not working") ||
          lowerLabel === "offline"
        ) {
          return { text: "OFFLINE", cls: "status-text--notworking" };
        }
        if (lowerLabel === "clear") {
          return { text: "CLEAR", cls: "status-text--clear" };
        }
        if (lowerLabel.includes("offer")) {
          return { text: "OFFER", cls: "status-text--offering" };
        }
        if (lowerLabel.includes("account") && lowerLabel.includes("busy")) {
          return { text: "BUSY ACC", cls: "status-text--busy" };
        }
        if (lowerLabel.includes("cash") && lowerLabel.includes("busy")) {
          return { text: "BUSY CASH", cls: "status-text--busy" };
        }
        if (lowerLabel.startsWith("busy")) {
          return { text: "BUSY", cls: "status-text--busy" };
        }
        if (lowerLabel.includes("street") || lowerLabel.includes("rank")) {
          return { text: "RANK", cls: "status-text--rank" };
        }
      }

      if (!code && !label) {
        return { text: "OFFLINE", cls: "status-text--notworking" };
      }

      const text = (label || code).toString().toUpperCase();
      return { text, cls: "status-text--unknown" };
    }

    function statusTextSpan(rawCode, rawLabel) {
      const mapped = mapDriverStatus(rawCode, rawLabel);
      return `<span class="status-text ${mapped.cls}">${mapped.text}</span>`;
    }

    function formatUpdated(ts) {
      if (!ts) return "";
      const d = new Date(ts);
      if (Number.isNaN(d.getTime())) return "";
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }

    function rowChrome(on){
      if (highlightMode === "background") {
        if (on === true)  return "row row-bg-online";
        if (on === false) return "row row-bg-offline";
        return "row row-bg-neutral";
      }
      if (highlightMode === "border") {
        if (on === true)  return "row row-border-online";
        if (on === false) return "row row-border-offline";
        return "row row-border-neutral";
      }
      return "row";
    }

    // Callsign ‚Üí Status ‚Üí Reg ‚Üí Taxi Plate
    function rowHTML(v, highlight=false) {
      const cs   = getCallsign(v) || "";
      const plat = getPlate(v)    || "‚Äî";
      const reg  = getReg(v)      || "‚Äî";
      const on   = onlineFor(cs);
      const ts   = updatedFor(cs);
      const code = driverStatusCodeFor(cs);
      const label= driverStatusLabelFor(cs);

      const rowClass = rowChrome(on) + (highlight ? " row-flash" : "");
      const tooltip = ts ? ("Last update: " + new Date(ts).toLocaleString()) : "";
      const updatedLabel = formatUpdated(ts);

      return `
        <div id="row-${normKey(cs)}" class="${rowClass}" title="${tooltip}">
          <!-- Callsign -->
          <div class="cell mono strong">${cs || "(no)"}</div>

          <!-- Status (second column) -->
          <div class="cell cell-status">
            <div class="status-main">
              ${statusTextSpan(code, label)}
            </div>
            ${updatedLabel ? `<div class="status-updated">Updated ${updatedLabel}</div>` : ""}
          </div>

          <!-- Reg Plate -->
          <div class="cell">
            <span class="pill-reg mono strong">${reg}</span>
          </div>

          <!-- Taxi Plate -->
          <div class="cell">
            <span class="pill-muted mono">${plat}</span>
          </div>
        </div>
      `;
    }

    function render(changedKey=null) {
      if (!master.length) {
        rowsEl.innerHTML = '<div class="empty-state">No vehicles to display.</div>';
        skeletonEl.classList.add("hidden");
        return;
      }
      const html = master.map(v => {
        const cs = getCallsign(v);
        const hi = changedKey && normKey(cs) === changedKey;
        return rowHTML(v, hi);
      }).join("");
      rowsEl.innerHTML = html;
      skeletonEl.classList.add("hidden");
    }

    let searchTimer = null;
    function applyFiltersAndRender(changedKey=null){
      const q = searchEl.value.trim().toLowerCase();
      let arr = baseMaster;

      if (q) {
        arr = arr.filter(v => {
          const cs = String(getCallsign(v)).toLowerCase();
          const plate = String(getPlate(v)).toLowerCase();
          const reg = String(getReg(v)).toLowerCase();
          return cs.includes(q) || plate.includes(q) || reg.includes(q);
        });
      }

      const filterMode = statusFilterEl.value;
      if (filterMode !== "all") {
        arr = arr.filter(v => {
          const on = onlineFor(getCallsign(v));
          if (filterMode === "online") return on === true;
          if (filterMode === "offline") return on === false;
          return true;
        });
      }

      const mode = sortEl.value;
      if (mode === "plateNumber") arr.sort((a,b) => compare(a,b,getPlate));
      else if (mode === "registration") arr.sort((a,b) => compare(a,b,getReg));
      else arr.sort((a,b) => compare(a,b,getCallsign));

      master = arr;

      const onlineCount  = arr.reduce((n, v) => n + (onlineFor(getCallsign(v)) === true  ? 1 : 0), 0);
      const offlineCount = arr.reduce((n, v) => n + (onlineFor(getCallsign(v)) === false ? 1 : 0), 0);
      const total = arr.length;

      statusCountsEl.innerHTML =
        'üü¢ Working: <b>' + onlineCount + '</b>&nbsp;&nbsp;' +
        'üî¥ Offline: <b>' + offlineCount + '</b>&nbsp;&nbsp;' +
        '‚ö™ Total: <b>' + total + '</b>';

      render(changedKey);
    }

    refreshBtn.addEventListener("click", () => {
      fetchVehicles();
      fetchOnline();
    });
    searchEl.addEventListener("input", () => {
      clearTimeout(searchTimer);
      searchTimer = setTimeout(() => applyFiltersAndRender(), 120);
    });
    sortEl.addEventListener("change", () => applyFiltersAndRender());
    statusFilterEl.addEventListener("change", () => applyFiltersAndRender());

    async function fetchVehicles() {
      try {
        skeletonEl.classList.remove("hidden");
        const res = await fetch(API_VEHICLES, { headers: { "Cache-Control": "no-cache" }});
        if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText);
        const data = await res.json();
        const list = getList(data);

        const seen = new Map();
        for (const v of list) {
          if (!isActive(v) || !hasHackneyCapability(v)) continue;

          const obj = {
            ...v,
            callsign: getCallsign(v),
            plateNumber: getPlate(v),
            registration: getReg(v),
          };

          if (!(obj.callsign || obj.plateNumber || obj.registration)) continue;

          const key = normKey(obj.callsign || obj.registration || obj.plateNumber);
          if (!seen.has(key)) {
            seen.set(key, obj);
          } else {
            const prev = seen.get(key);
            if (!prev.callsign && obj.callsign) seen.set(key, obj);
          }
        }

        baseMaster = Array.from(seen.values());
        applyFiltersAndRender();
      } catch (e) {
        skeletonEl.classList.add("hidden");
        rowsEl.innerHTML = '<div class="error-text">Failed to load vehicles: ' + e.message + '</div>';
      }
    }

    async function fetchOnline() {
      try {
        const res = await fetch(ONLINE_URL, { headers: { "Cache-Control":"no-cache" }});
        if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText);
        const data = await res.json();
        onlineMap = buildOnlineMap(data);
        applyFiltersAndRender();
      } catch (e) {
        // ignore; SSE may cover it
      }
    }

    function wireSSE() {
      if (!("EventSource" in window)) return false;
      try {
        const es = new EventSource(SSE_URL);
        es.addEventListener("open", () => {});
        es.addEventListener("error", () => {
          if (!document.hidden) startPollingFallback();
        });

        es.addEventListener("snapshot", (evt) => {
          try {
            const payload = JSON.parse(evt.data);
            const m = new Map();
            for (const item of (payload?.data || [])) {
              if (!item?.callsign) continue;
              const key = normKey(item.callsign);
              m.set(key, {
                online: !!item.online,
                updatedAt: item.updatedAt || null,
                driverStatusLabel: item.driverStatus || null,
                driverStatusCode: item.driverStatusCode || null,
              });
            }
            onlineMap = m;
            applyFiltersAndRender();
          } catch {}
        });

        es.addEventListener("status", (evt) => {
          try {
            const p = JSON.parse(evt.data);
            if (!p?.callsign) return;
            const key = normKey(p.callsign);
            const prev = onlineMap.get(key)?.online;
            const prevLabel = onlineMap.get(key)?.driverStatusLabel || null;
            const prevCode  = onlineMap.get(key)?.driverStatusCode || null;
            onlineMap.set(key, {
              online: (typeof p.online === "boolean" ? p.online : prev),
              updatedAt: p.updatedAt || null,
              driverStatusLabel: p.driverStatus ?? prevLabel,
              driverStatusCode: p.driverStatusCode ?? prevCode,
            });
            applyFiltersAndRender(prev !== p.online ? key : null);
          } catch {}
        });

        return true;
      } catch {
        return false;
      }
    }

    function startPollingFallback() {
      clearInterval(statusPollTimer);
      statusPollTimer = setInterval(fetchOnline, STATUS_REFRESH_MS);
    }

    setInterval(fetchVehicles, VEHICLE_REFRESH_MS);
    document.addEventListener("visibilitychange", () => { if (!document.hidden) fetchOnline(); });

    (async () => {
      await fetchVehicles();
      const ok = wireSSE();
      if (!ok) startPollingFallback(); else fetchOnline();
      adjustStickyOffset();
    })();
  </script>
</body>
</html>
