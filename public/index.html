<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Active Hackneys ‚Äî Callsign ¬∑ Plate ¬∑ Reg ¬∑ Status</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <link rel="stylesheet" href="hackney.css" />
</head>
<body>
  <!-- HEADER -->
  <header id="appHeader" class="header">
    <div class="header-inner">
      <div class="brand-box">N</div>
      <div class="header-title-wrap">
        <h1 class="header-title">Active Hackney Drivers</h1>
      </div>
      <div class="font-buttons">
        <button id="fontSm" class="btn-ghost" title="Smaller text">A‚àí</button>
        <button id="fontLg" class="btn-ghost" title="Larger text">A+</button>
      </div>
      <button id="refreshBtn" class="btn-outline">
        Refresh
      </button>
    </div>

    <!-- Controls -->
    <div class="header-controls">
      <div class="controls-row">
        <!-- Search -->
        <div class="search-box">
          <span class="search-icon">üîç</span>
          <input id="searchInput" type="search" inputmode="search"
                 placeholder="Search callsign, taxi plate or reg‚Ä¶"
                 class="search-input" />
        </div>

        <!-- Filter by Status -->
        <select id="statusFilter" class="control-select">
          <option value="all">Show: All</option>
          <option value="online">Online only</option>
          <option value="offline">Offline only</option>
        </select>

        <!-- Sort -->
        <select id="sortSelect" class="control-select">
          <option value="callsign">Sort: Callsign</option>
          <option value="plateNumber">Sort: Plate</option>
          <option value="registration">Sort: Registration</option>
        </select>

        <!-- Row highlight mode -->
        <label class="control-label">Row highlight</label>
        <select id="hlSelect" class="control-select">
          <option value="none">None</option>
          <option value="border">Border</option>
          <option value="background" selected>Background</option>
        </select>
      </div>

      <!-- Status counters -->
      <div id="statusCounts" class="status-counts"></div>

      <!-- Column headers -->
      <div id="colHeader" class="table-header-wrap">
        <div class="table-row table-header">
          <div>Callsign</div>
          <div>Taxi Plate</div>
          <div>Reg Plate</div>
          <div>Driver Status</div>
          <div class="text-right">Status</div>
        </div>
      </div>
    </div>
  </header>

  <!-- LIST -->
  <main class="main">
    <section class="card">
      <div id="rows" aria-live="polite"></div>
      <div id="skeleton" class="skeleton">
        <div class="skeleton-row"></div>
        <div class="skeleton-row"></div>
        <div class="skeleton-row"></div>
      </div>
    </section>
  </main>

  <script>
    // ===== Root font size (A‚àí / A+) =====
    const MIN_PX = 15, MAX_PX = 20, ROOT_KEY = "root-font-px";
    const applyRootPx = (px) => document.documentElement.style.fontSize = px + "px";
    let rootPx = Math.min(MAX_PX, Math.max(MIN_PX, Number(localStorage.getItem(ROOT_KEY) || 16)));
    applyRootPx(rootPx);
    document.getElementById("fontSm").addEventListener("click", () => {
      rootPx = Math.max(MIN_PX, rootPx - 1);
      applyRootPx(rootPx);
      localStorage.setItem(ROOT_KEY, rootPx);
      adjustStickyOffset();
    });
    document.getElementById("fontLg").addEventListener("click", () => {
      rootPx = Math.min(MAX_PX, rootPx + 1);
      applyRootPx(rootPx);
      localStorage.setItem(ROOT_KEY, rootPx);
      adjustStickyOffset();
    });

    // ===== Dynamic sticky offset for column headers =====
    function adjustStickyOffset(){
      const h = document.getElementById("appHeader")?.offsetHeight || 60;
      const ch = document.getElementById("colHeader");
      if (ch) ch.style.top = h + "px";
    }
    window.addEventListener("resize", adjustStickyOffset);
    document.addEventListener("DOMContentLoaded", adjustStickyOffset);

    // ===== CONFIG =====
    const API_VEHICLES = "/api/vehicles";
    const ONLINE_URL   = "/api/status";
    const SSE_URL      = "/api/status/stream";
    const VEHICLE_REFRESH_MS = 60000;
    const STATUS_REFRESH_MS  = 5000;
    const SHOW_ALL = new URL(location.href).searchParams.get("all") === "1";

    const STALE_MS = 12 * 60 * 60 * 1000; // 12 hours
    function isStale(updatedAt){
      if (!updatedAt) return true;
      const t = new Date(updatedAt).getTime();
      return !Number.isFinite(t) || (Date.now() - t) > STALE_MS;
    }

    // ===== HIGHLIGHT MODE =====
    const HL_KEY = "row-highlight-mode";
    const hlSelect = document.getElementById("hlSelect");
    let highlightMode = localStorage.getItem(HL_KEY) || "background";
    hlSelect.value = highlightMode;
    hlSelect.addEventListener("change", () => {
      highlightMode = hlSelect.value;
      localStorage.setItem(HL_KEY, highlightMode);
      render();
    });

    // ===== HELPERS =====
    const getList = (data) =>
      Array.isArray(data) ? data :
      (data?.items || data?.results || data?.vehicles || data?.data || []);

    const getCallsign = (v) => v?.callsign ?? v?.callSign ?? v?.code ?? v?.mdtId ?? v?.mdtID ?? "";
    const getPlate    = (v) => v?.plateNumber ?? v?.plate ?? v?.registrationNumber ?? "";
    const getReg      = (v) => v?.registration ?? v?.vrm ?? v?.reg ?? "";
    const normKey     = (s) => String(s || "").trim().toUpperCase();
    const toNum       = (s) => { const n = Number(String(s).trim()); return Number.isFinite(n) ? n : null; };

    const isActive = (v) => {
      if (typeof v?.isActive === "boolean") return v.isActive;
      if (typeof v?.active === "boolean") return v.active;
      if (typeof v?.isArchived === "boolean") return !v.isArchived;
      if (typeof v?.archived === "boolean") return !v.archived;
      return true;
    };

    const hasHackneyCapability = (v) => {
      if (SHOW_ALL) return true;
      if (Array.isArray(v?.capabilityIds)) return v.capabilityIds.includes(14);
      if (Array.isArray(v?.capabilities)) {
        return v.capabilities.some(c => {
          if (typeof c === "number") return c === 14;
          if (typeof c === "string") return c === "14" || c.toLowerCase().includes("hackney");
          if (c && typeof c === "object") return c.id === 14 || (c.name && String(c.name).toLowerCase().includes("hackney"));
          return false;
        });
      }
      if (typeof v?.capability === "number") return v.capability === 14;
      if (typeof v?.capability === "string") return v.capability?.toLowerCase?.().includes("hackney") || v.capability === "14";
      return false;
    };

    const compare = (a, b, field) => {
      const A = String(field(a) ?? ""); const B = String(field(b) ?? "");
      const na = toNum(A), nb = toNum(B);
      if (na !== null && nb !== null) return na - nb;
      return A.localeCompare(B, undefined, { numeric: true, sensitivity: "base" });
    };

    // ===== ELEMENTS / STATE =====
    const rowsEl     = document.getElementById("rows");
    const skeletonEl = document.getElementById("skeleton");
    const refreshBtn = document.getElementById("refreshBtn");
    const searchEl   = document.getElementById("searchInput");
    const sortEl     = document.getElementById("sortSelect");
    const statusFilterEl = document.getElementById("statusFilter");
    const statusCountsEl = document.getElementById("statusCounts");

    let baseMaster = [];
    let master = [];
    // onlineMap: key -> { online, updatedAt, lastPingAt, driverStatus }
    let onlineMap = new Map();
    let statusPollTimer = null;

    // ===== STATUS helpers =====
    function inferOnline(obj) {
      if (typeof obj?.online === "boolean") return obj.online;
      const s = (obj?.status ?? obj?.shift ?? obj?.state ?? obj?.availability ?? "").toString().toLowerCase();
      if (["on","online","active","started","loggedin","open","available","true","1"].includes(s)) return true;
      if (["off","offline","inactive","ended","loggedout","closed","unavailable","false","0"].includes(s)) return false;
      const sub = (obj?.SubEventType ?? obj?.subEventType ?? "").toString().toLowerCase();
      if (sub === "started") return true;
      if (sub === "ended") return false;
      return null;
    }

    function extractCallsign(obj) {
      const direct = obj?.callsign ?? obj?.callSign ?? obj?.code ?? obj?.mdtId ?? obj?.mdtID ?? obj?.vehicleCode ?? obj?.driverCode ?? null;
      if (direct) return direct;
      const d = obj?.Driver || obj?.driver || {};
      const v = obj?.Vehicle || obj?.vehicle || {};
      return d?.Callsign ?? d?.callsign ?? d?.callSign ?? v?.Callsign ?? v?.callsign ?? v?.callSign ?? null;
    }

    function extractDriverStatus(obj) {
      const raw =
        obj?.driverStatus ??
        obj?.statusText ??
        obj?.stateText ??
        obj?.driver_state ??
        obj?.status ??
        obj?.availability ??
        "";
      return String(raw || "").trim();
    }

    function computeEffectiveOnline(rec) {
      if (!rec) return null;
      if (rec.lastPingAt) {
        const t = new Date(rec.lastPingAt).getTime();
        if (Number.isFinite(t) && Date.now() - t > (Number(process.env?.PING_TIMEOUT_MINUTES || 5) * 60 * 1000 || 5 * 60 * 1000)) {
          return false;
        }
      }
      if (typeof rec.online === "boolean") return rec.online;
      return null;
    }

    function buildOnlineMap(data) {
      const list = getList(data);
      const map = new Map();
      for (const item of list) {
        const cs = item?.callsign ?? extractCallsign(item);
        if (!cs) continue;

        let online = null;
        if (typeof item?.online === "boolean") {
          online = item.online;
        } else {
          online = inferOnline(item);
        }
        if (online === null && !item?.driverStatus && !item?.statusText) {
          continue;
        }

        map.set(normKey(cs), {
          online,
          updatedAt: item?.updatedAt || item?.timestamp || item?.time || item?.ModifiedDate || null,
          driverStatus: extractDriverStatus(item) || null,
        });
      }
      return map;
    }

    const onlineFor       = (cs) => {
      const rec = onlineMap.get(normKey(cs));
      if (!rec) return null;
      return rec.online;
    };
    const updatedFor      = (cs) => onlineMap.get(normKey(cs))?.updatedAt || null;
    const driverStatusFor = (cs) => onlineMap.get(normKey(cs))?.driverStatus || null;

    // ===== BADGE (dot only) =====
    function badge(on, updatedAt) {
      const dotClass =
        on === true  ? "dot dot-online" :
        on === false ? "dot dot-offline" :
                       "dot dot-unknown";
      const tt = updatedAt
        ? "Last update: " + new Date(updatedAt).toLocaleString()
        : "No timestamp";
      return `<span class="${dotClass}" title="${tt}"></span>`;
    }

    // ===== ROW chrome =====
    function rowChrome(on){
      if (highlightMode === "background") {
        if (on === true)  return "row row-bg-online";
        if (on === false) return "row row-bg-offline";
        return "row row-bg-neutral";
      }
      if (highlightMode === "border") {
        if (on === true)  return "row row-border-online";
        if (on === false) return "row row-border-offline";
        return "row row-border-neutral";
      }
      return "row";
    }

    // ===== ROW =====
    function rowHTML(v, highlight=false) {
      const cs   = getCallsign(v) || "";
      const plat = getPlate(v)    || "‚Äî";
      const reg  = getReg(v)      || "‚Äî";
      const on   = onlineFor(cs);
      const ts   = updatedFor(cs);
      const ds   = driverStatusFor(cs) || "‚Äî";

      const rowClass = rowChrome(on) + (highlight ? " row-flash" : "");

      return `
        <div id="row-${normKey(cs)}" class="${rowClass}">
          <div class="cell mono strong">${cs || "(no)"}</div>
          <div class="cell">
            <span class="pill-muted mono">${plat}</span>
          </div>
          <div class="cell">
            <span class="pill-reg mono strong">${reg}</span>
          </div>
          <div class="cell driver-status-text">${ds}</div>
          <div class="cell text-right cell-status">
            ${badge(on, ts)}
          </div>
        </div>
      `;
    }

    function render(changedKey=null) {
      if (!master.length) {
        rowsEl.innerHTML = '<div class="empty-state">No vehicles to display.</div>';
        skeletonEl.classList.add("hidden");
        return;
      }
      const html = master.map(v => {
        const cs = getCallsign(v);
        const hi = changedKey && normKey(cs) === changedKey;
        return rowHTML(v, hi);
      }).join("");
      rowsEl.innerHTML = html;
      skeletonEl.classList.add("hidden");
    }

    // ===== FILTER / SORT / SEARCH =====
    let searchTimer = null;
    function applyFiltersAndRender(changedKey=null){
      const q = searchEl.value.trim().toLowerCase();
      let arr = baseMaster;

      if (q) {
        arr = arr.filter(v => {
          const cs = String(getCallsign(v)).toLowerCase();
          const plate = String(getPlate(v)).toLowerCase();
          const reg = String(getReg(v)).toLowerCase();
          return cs.includes(q) || plate.includes(q) || reg.includes(q);
        });
      }

      const filterMode = statusFilterEl.value;
      if (filterMode !== "all") {
        arr = arr.filter(v => {
          const on = onlineFor(getCallsign(v));
          if (filterMode === "online") return on === true;
          if (filterMode === "offline") return on === false;
          return true;
        });
      }

      const mode = sortEl.value;
      if (mode === "plateNumber") arr.sort((a,b) => compare(a,b,getPlate));
      else if (mode === "registration") arr.sort((a,b) => compare(a,b,getReg));
      else arr.sort((a,b) => compare(a,b,getCallsign));

      master = arr;

      const onlineCount  = arr.reduce((n, v) => n + (onlineFor(getCallsign(v)) === true  ? 1 : 0), 0);
      const offlineCount = arr.reduce((n, v) => n + (onlineFor(getCallsign(v)) === false ? 1 : 0), 0);
      const total = arr.length;

      statusCountsEl.innerHTML =
        'üü¢ Online: <b>' + onlineCount + '</b>&nbsp;&nbsp;' +
        'üî¥ Offline: <b>' + offlineCount + '</b>&nbsp;&nbsp;' +
        '‚ö™ Total: <b>' + total + '</b>';

      render(changedKey);
    }

    refreshBtn.addEventListener("click", () => {
      fetchVehicles();
      fetchOnline();
    });
    searchEl.addEventListener("input", () => {
      clearTimeout(searchTimer);
      searchTimer = setTimeout(() => applyFiltersAndRender(), 120);
    });
    sortEl.addEventListener("change", () => applyFiltersAndRender());
    statusFilterEl.addEventListener("change", () => applyFiltersAndRender());

    // ===== DATA LOADERS =====
    async function fetchVehicles() {
      try {
        skeletonEl.classList.remove("hidden");
        const res = await fetch(API_VEHICLES, { headers: { "Cache-Control": "no-cache" }});
        if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText);
        const data = await res.json();
        const list = getList(data);

        const seen = new Map();
        for (const v of list) {
          if (!isActive(v) || !hasHackneyCapability(v)) continue;

          const obj = {
            ...v,
            callsign: getCallsign(v),
            plateNumber: getPlate(v),
            registration: getReg(v),
          };

          if (!(obj.callsign || obj.plateNumber || obj.registration)) continue;

          const key = normKey(obj.callsign || obj.registration || obj.plateNumber);
          if (!seen.has(key)) {
            seen.set(key, obj);
          } else {
            const prev = seen.get(key);
            if (!prev.callsign && obj.callsign) seen.set(key, obj);
          }
        }

        baseMaster = Array.from(seen.values());
        applyFiltersAndRender();
      } catch (e) {
        skeletonEl.classList.add("hidden");
        rowsEl.innerHTML = '<div class="error-text">Failed to load vehicles: ' + e.message + '</div>';
      }
    }

    async function fetchOnline() {
      try {
        const res = await fetch(ONLINE_URL, { headers: { "Cache-Control":"no-cache" }});
        if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText);
        const data = await res.json();
        onlineMap = buildOnlineMap(data);
        applyFiltersAndRender();
      } catch (e) {
        // ignore; SSE may cover it
      }
    }

    // ===== LIVE UPDATES (SSE + fallback) =====
    function wireSSE() {
      if (!("EventSource" in window)) return false;
      try {
        const es = new EventSource(SSE_URL);
        es.addEventListener("open", () => {});
        es.addEventListener("error", () => {
          if (!document.hidden) startPollingFallback();
        });

        es.addEventListener("snapshot", (evt) => {
          try {
            const payload = JSON.parse(evt.data);
            const m = new Map();
            for (const item of (payload?.data || [])) {
              if (!item?.callsign) continue;
              m.set(normKey(item.callsign), {
                online: !!item.online,
                updatedAt: item.updatedAt || null,
                driverStatus: item.driverStatus || null,
              });
            }
            onlineMap = m;
            applyFiltersAndRender();
          } catch {}
        });

        es.addEventListener("status", (evt) => {
          try {
            const p = JSON.parse(evt.data);
            if (!p?.callsign) return;
            const key = normKey(p.callsign);
            const prev = onlineMap.get(key)?.online;
            const prevStatus = onlineMap.get(key)?.driverStatus || null;
            onlineMap.set(key, {
              online: !!p.online,
              updatedAt: p.updatedAt || null,
              driverStatus: p.driverStatus ?? prevStatus,
            });
            applyFiltersAndRender(prev !== p.online ? key : null);
          } catch {}
        });

        return true;
      } catch {
        return false;
      }
    }

    function startPollingFallback() {
      clearInterval(statusPollTimer);
      statusPollTimer = setInterval(fetchOnline, STATUS_REFRESH_MS);
    }

    // ===== INIT =====
    setInterval(fetchVehicles, VEHICLE_REFRESH_MS);
    document.addEventListener("visibilitychange", () => { if (!document.hidden) fetchOnline(); });

    (async () => {
      await fetchVehicles();
      const ok = wireSSE();
      if (!ok) startPollingFallback(); else fetchOnline();
      adjustStickyOffset();
    })();
  </script>
</body>
</html>
