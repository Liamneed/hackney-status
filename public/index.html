<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Active Hackneys ‚Äî Callsign ¬∑ Plate ¬∑ Reg ¬∑ Status</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <link rel="stylesheet" href="hackney.css" />

  <!-- Extra styles just for driver-status colours -->
  <style>
    .driver-status-text {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .driver-status-off {
      color: #9ca3af;
      font-style: italic;
      font-weight: 500;
    }
    .driver-status-clear {
      color: #16a34a;
      font-weight: 600;
    }
    .driver-status-busy {
      color: #ca8a04;
      font-weight: 600;
    }
    .driver-status-unknown {
      color: #64748b;
      font-style: italic;
    }

    @media (max-width: 640px) {
      .cell.driver-status-text {
        max-width: 9rem;
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <!-- HEADER -->
  <header id="appHeader" class="header">
    <div class="header-inner">
      <div class="brand-box">N</div>
      <div class="header-title-wrap">
        <h1 class="header-title">Active Hackney Drivers</h1>
      </div>
      <div class="font-buttons">
        <button id="fontSm" class="btn-ghost" title="Smaller text">A‚àí</button>
        <button id="fontLg" class="btn-ghost" title="Larger text">A+</button>
      </div>
      <button id="refreshBtn" class="btn-outline">
        Refresh
      </button>
    </div>

    <!-- Controls -->
    <div class="header-controls">
      <div class="controls-row">
        <!-- Search -->
        <div class="search-box">
          <span class="search-icon">üîç</span>
          <input id="searchInput" type="search" inputmode="search"
                 placeholder="Search callsign, taxi plate or reg‚Ä¶"
                 class="search-input" />
        </div>

        <!-- Filter by Status -->
        <select id="statusFilter" class="control-select">
          <option value="all">Show: All</option>
          <option value="online">Working only</option>
          <option value="offline">Not working only</option>
        </select>

        <!-- Sort -->
        <select id="sortSelect" class="control-select">
          <option value="callsign">Sort: Callsign</option>
          <option value="plateNumber">Sort: Plate</option>
          <option value="registration">Sort: Registration</option>
        </select>

        <!-- Row highlight mode -->
        <label class="control-label">Row highlight</label>
        <select id="hlSelect" class="control-select">
          <option value="none">None</option>
          <option value="border">Border</option>
          <option value="background" selected>Background</option>
        </select>
      </div>

      <!-- Status counters -->
      <div id="statusCounts" class="status-counts"></div>

      <!-- Column headers (4 columns) -->
      <div id="colHeader" class="table-header-wrap">
        <div class="table-row table-header">
          <div>Callsign</div>
          <div>Taxi Plate</div>
          <div>Reg Plate</div>
          <div>Driver Status</div>
        </div>
      </div>
    </div>
  </header>

  <!-- LIST -->
  <main class="main">
    <section class="card">
      <div id="rows" aria-live="polite"></div>
      <div id="skeleton" class="skeleton">
        <div class="skeleton-row"></div>
        <div class="skeleton-row"></div>
        <div class="skeleton-row"></div>
      </div>
    </section>
  </main>

  <script>
    // ===== Root font size (A‚àí / A+) =====
    const MIN_PX = 15, MAX_PX = 20, ROOT_KEY = "root-font-px";
    const applyRootPx = (px) => document.documentElement.style.fontSize = px + "px";
    let rootPx = Math.min(MAX_PX, Math.max(MIN_PX, Number(localStorage.getItem(ROOT_KEY) || 16)));
    applyRootPx(rootPx);
    document.getElementById("fontSm").addEventListener("click", () => {
      rootPx = Math.max(MIN_PX, rootPx - 1);
      applyRootPx(rootPx);
      localStorage.setItem(ROOT_KEY, rootPx);
      adjustStickyOffset();
    });
    document.getElementById("fontLg").addEventListener("click", () => {
      rootPx = Math.min(MAX_PX, rootPx + 1);
      applyRootPx(rootPx);
      localStorage.setItem(ROOT_KEY, rootPx);
      adjustStickyOffset();
    });

    // ===== Dynamic sticky offset =====
    function adjustStickyOffset(){
      const h = document.getElementById("appHeader")?.offsetHeight || 60;
      const ch = document.getElementById("colHeader");
      if (ch) ch.style.top = h + "px";
    }
    window.addEventListener("resize", adjustStickyOffset);
    document.addEventListener("DOMContentLoaded", adjustStickyOffset);

    // ===== CONFIG =====
    const API_VEHICLES = "/api/vehicles";
    const ONLINE_URL   = "/api/status";
    const SSE_URL      = "/api/status/stream";
    const VEHICLE_REFRESH_MS = 60000;
    const STATUS_REFRESH_MS  = 5000;
    const SHOW_ALL = new URL(location.href).searchParams.get("all") === "1";

    const STALE_MS = 12 * 60 * 60 * 1000;
    function isStale(updatedAt){
      if (!updatedAt) return true;
      const t = new Date(updatedAt).getTime();
      return !Number.isFinite(t) || (Date.now() - t) > STALE_MS;
    }

    // ===== HIGHLIGHT MODE =====
    const HL_KEY = "row-highlight-mode";
    const hlSelect = document.getElementById("hlSelect");
    let highlightMode = localStorage.getItem(HL_KEY) || "background";
    hlSelect.value = highlightMode;
    hlSelect.addEventListener("change", () => {
      highlightMode = hlSelect.value;
      localStorage.setItem(HL_KEY, highlightMode);
      render();
    });

    // ===== Status map (same as backend) =====
    const STATUS_DEFS = {
      NotWorking:                  { label: "Not Working",    kind: "off" },
      Clear:                       { label: "Clear",          kind: "clear" },
      BusyMeterOff:                { label: "Dispatched",     kind: "busy" },
      BusyMeterOffAccount:         { label: "Dispatched",     kind: "busy" },
      BusyMeterOnFromMeterOffCash: { label: "Picked up",      kind: "busy" },
      BusyMeterOnFromMeterOffAccount:{ label: "Picked up",    kind: "busy" },
      BusyMeterOnFromClear:        { label: "Street Booking", kind: "busy" },
      JobOffered:                  { label: "Offering Job",   kind: "busy" },
    };

    function statusTypeToDescription(type) {
      if (!type) return null;
      const def = STATUS_DEFS[type];
      return def ? def.label : type;
    }

    function statusTypeToKind(type) {
      const def = STATUS_DEFS[type];
      return def ? def.kind : "unknown";
    }

    // ===== HELPERS =====
    const getList = (data) =>
      Array.isArray(data) ? data :
      (data?.items || data?.results || data?.vehicles || data?.data || []);

    const getCallsign = (v) => v?.callsign ?? v?.callSign ?? v?.code ?? v?.mdtId ?? v?.mdtID ?? "";
    const getPlate    = (v) => v?.plateNumber ?? v?.plate ?? v?.registrationNumber ?? "";
    const getReg      = (v) => v?.registration ?? v?.vrm ?? v?.reg ?? "";
    const normKey     = (s) => String(s || "").trim().toUpperCase();
    const toNum       = (s) => { const n = Number(String(s).trim()); return Number.isFinite(n) ? n : null; };

    const isActive = (v) => {
      if (typeof v?.isActive === "boolean") return v.isActive;
      if (typeof v?.active === "boolean") return v.active;
      if (typeof v?.isArchived === "boolean") return !v.isArchived;
      if (typeof v?.archived === "boolean") return !v.archived;
      return true;
    };

    const hasHackneyCapability = (v) => {
      if (SHOW_ALL) return true;
      if (Array.isArray(v?.capabilityIds)) return v.capabilityIds.includes(14);
      if (Array.isArray(v?.capabilities)) {
        return v.capabilities.some(c => {
          if (typeof c === "number") return c === 14;
          if (typeof c === "string") return c === "14" || c.toLowerCase().includes("hackney");
          if (c && typeof c === "object") return c.id === 14 || (c.name && String(c.name).toLowerCase().includes("hackney"));
          return false;
        });
      }
      if (typeof v?.capability === "number") return v.capability === 14;
      if (typeof v?.capability === "string") return v.capability?.toLowerCase?.().includes("hackney") || v.capability === "14";
      return false;
    };

    const compare = (a, b, field) => {
      const A = String(field(a) ?? ""); const B = String(field(b) ?? "");
      const na = toNum(A), nb = toNum(B);
      if (na !== null && nb !== null) return na - nb;
      return A.localeCompare(B, undefined, { numeric: true, sensitivity: "base" });
    };

    // ===== ELEMENTS / STATE =====
    const rowsEl     = document.getElementById("rows");
    const skeletonEl = document.getElementById("skeleton");
    const refreshBtn = document.getElementById("refreshBtn");
    const searchEl   = document.getElementById("searchInput");
    const sortEl     = document.getElementById("sortSelect");
    const statusFilterEl = document.getElementById("statusFilter");
    const statusCountsEl = document.getElementById("statusCounts");

    let baseMaster = [];
    let master = [];
    // onlineMap: key -> { updatedAt, statusType, label }
    let onlineMap = new Map();
    let statusPollTimer = null;

    function extractCallsign(obj) {
      const direct = obj?.callsign ?? obj?.callSign ?? obj?.code ?? obj?.mdtId ?? obj?.mdtID ?? obj?.vehicleCode ?? obj?.driverCode ?? null;
      if (direct) return direct;
      const d = obj?.Driver || obj?.driver || {};
      const v = obj?.Vehicle || obj?.vehicle || {};
      return d?.Callsign ?? d?.callsign ?? d?.callSign ?? v?.Callsign ?? v?.callsign ?? v?.callSign ?? null;
    }

    // Build map from /api/status or SSE payload
    function buildOnlineMap(data) {
      const list = getList(data);
      const map = new Map();
      for (const item of list) {
        const cs = item?.callsign ?? extractCallsign(item);
        if (!cs) continue;

        const statusType = item.statusType || null;
        const label      = item.driverStatus || statusTypeToDescription(statusType) || null;
        const updatedAt  = item.updatedAt || item.timestamp || item.time || item.ModifiedDate || null;

        map.set(normKey(cs), {
          updatedAt,
          statusType,
          label,
        });
      }
      return map;
    }

    function statusForCallsign(cs) {
      const key = normKey(cs);
      const rec = onlineMap.get(key) || {};
      let type  = rec.statusType || null;
      const updatedAt = rec.updatedAt || null;

      // Default: NotWorking if we have NO statusType
      if (!type) type = "NotWorking";

      const kind = statusTypeToKind(type);
      const label = rec.label || statusTypeToDescription(type) || "Not Working";

      return { type, label, kind, updatedAt };
    }

    function isWorkingKind(kind) {
      return kind === "clear" || kind === "busy";
    }

    function onlineFor(cs) {
      const { kind } = statusForCallsign(cs);
      return isWorkingKind(kind);
    }

    const updatedFor = (cs) => statusForCallsign(cs).updatedAt;

    // ===== ROW chrome =====
    function rowChrome(kind){
      if (highlightMode === "background") {
        if (kind === "clear") return "row row-bg-online";
        if (kind === "busy")  return "row row-bg-offline"; // amber-ish in CSS if you want
        if (kind === "off")   return "row row-bg-neutral";
        return "row row-bg-neutral";
      }
      if (highlightMode === "border") {
        if (kind === "clear") return "row row-border-online";
        if (kind === "busy")  return "row row-border-offline";
        if (kind === "off")   return "row row-border-neutral";
        return "row row-border-neutral";
      }
      return "row";
    }

    // ===== ROW =====
    function rowHTML(v, highlight=false) {
      const cs   = getCallsign(v) || "";
      const plat = getPlate(v)    || "‚Äî";
      const reg  = getReg(v)      || "‚Äî";

      const st = statusForCallsign(cs);
      const kind = st.kind;
      const label = st.label;

      const rowClass = rowChrome(kind) + (highlight ? " row-flash" : "");
      const statusClass =
        kind === "off"     ? "driver-status-off" :
        kind === "clear"   ? "driver-status-clear" :
        kind === "busy"    ? "driver-status-busy" :
                             "driver-status-unknown";

      return `
        <div id="row-${normKey(cs)}" class="${rowClass}">
          <div class="cell mono strong">${cs || "(no)"}</div>
          <div class="cell">
            <span class="pill-muted mono">${plat}</span>
          </div>
          <div class="cell">
            <span class="pill-reg mono strong">${reg}</span>
          </div>
          <div class="cell driver-status-text ${statusClass}">${label}</div>
        </div>
      `;
    }

    function render(changedKey=null) {
      if (!master.length) {
        rowsEl.innerHTML = '<div class="empty-state">No vehicles to display.</div>';
        skeletonEl.classList.add("hidden");
        return;
      }
      const html = master.map(v => {
        const cs = getCallsign(v);
        const hi = changedKey && normKey(cs) === changedKey;
        return rowHTML(v, hi);
      }).join("");
      rowsEl.innerHTML = html;
      skeletonEl.classList.add("hidden");
    }

    // ===== FILTER / SORT / SEARCH =====
    let searchTimer = null;
    function applyFiltersAndRender(changedKey=null){
      const q = searchEl.value.trim().toLowerCase();
      let arr = baseMaster;

      if (q) {
        arr = arr.filter(v => {
          const cs = String(getCallsign(v)).toLowerCase();
          const plate = String(getPlate(v)).toLowerCase();
          const reg = String(getReg(v)).toLowerCase();
          return cs.includes(q) || plate.includes(q) || reg.includes(q);
        });
      }

      const filterMode = statusFilterEl.value;
      if (filterMode !== "all") {
        arr = arr.filter(v => {
          const working = onlineFor(getCallsign(v));
          if (filterMode === "online")  return working === true;
          if (filterMode === "offline") return working === false;
          return true;
        });
      }

      const mode = sortEl.value;
      if (mode === "plateNumber") arr.sort((a,b) => compare(a,b,getPlate));
      else if (mode === "registration") arr.sort((a,b) => compare(a,b,getReg));
      else arr.sort((a,b) => compare(a,b,getCallsign));

      master = arr;

      let onlineCount = 0;
      let offlineCount = 0;
      for (const v of arr) {
        const working = onlineFor(getCallsign(v));
        if (working) onlineCount++;
        else offlineCount++;
      }

      const total = arr.length;

      statusCountsEl.innerHTML =
        'üü¢ Working: <b>' + onlineCount + '</b>&nbsp;&nbsp;' +
        '‚ö™ Not working: <b>' + offlineCount + '</b>&nbsp;&nbsp;' +
        'üöñ Total: <b>' + total + '</b>';

      render(changedKey);
    }

    refreshBtn.addEventListener("click", () => {
      fetchVehicles();
      fetchOnline();
    });
    searchEl.addEventListener("input", () => {
      clearTimeout(searchTimer);
      searchTimer = setTimeout(() => applyFiltersAndRender(), 120);
    });
    sortEl.addEventListener("change", () => applyFiltersAndRender());
    statusFilterEl.addEventListener("change", () => applyFiltersAndRender());

    // ===== DATA LOADERS =====
    async function fetchVehicles() {
      try {
        skeletonEl.classList.remove("hidden");
        const res = await fetch(API_VEHICLES, { headers: { "Cache-Control": "no-cache" }});
        if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText);
        const data = await res.json();
        const list = getList(data);

        const seen = new Map();
        for (const v of list) {
          if (!isActive(v) || !hasHackneyCapability(v)) continue;

          const obj = {
            ...v,
            callsign: getCallsign(v),
            plateNumber: getPlate(v),
            registration: getReg(v),
          };

          if (!(obj.callsign || obj.plateNumber || obj.registration)) continue;

          const key = normKey(obj.callsign || obj.registration || obj.plateNumber);
          if (!seen.has(key)) {
            seen.set(key, obj);
          } else {
            const prev = seen.get(key);
            if (!prev.callsign && obj.callsign) seen.set(key, obj);
          }
        }

        baseMaster = Array.from(seen.values());
        applyFiltersAndRender();
      } catch (e) {
        skeletonEl.classList.add("hidden");
        rowsEl.innerHTML = '<div class="error-text">Failed to load vehicles: ' + e.message + '</div>';
      }
    }

    async function fetchOnline() {
      try {
        const res = await fetch(ONLINE_URL, { headers: { "Cache-Control":"no-cache" }});
        if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText);
        const data = await res.json();
        onlineMap = buildOnlineMap(data);
        applyFiltersAndRender();
      } catch (e) {
        // ignore; SSE may cover it
      }
    }

    // ===== LIVE UPDATES (SSE + fallback) =====
    function wireSSE() {
      if (!("EventSource" in window)) return false;
      try {
        const es = new EventSource(SSE_URL);
        es.addEventListener("open", () => {});
        es.addEventListener("error", () => {
          if (!document.hidden) startPollingFallback();
        });

        es.addEventListener("snapshot", (evt) => {
          try {
            const payload = JSON.parse(evt.data);
            const m = new Map();
            for (const item of (payload?.data || [])) {
              if (!item?.callsign) continue;
              m.set(normKey(item.callsign), {
                updatedAt: item.updatedAt || null,
                statusType: item.statusType || null,
                label: item.driverStatus || null,
              });
            }
            onlineMap = m;
            applyFiltersAndRender();
          } catch {}
        });

        es.addEventListener("status", (evt) => {
          try {
            const p = JSON.parse(evt.data);
            if (!p?.callsign) return;
            const key = normKey(p.callsign);
            const prev = onlineMap.get(key) || {};
            onlineMap.set(key, {
              updatedAt: p.updatedAt || prev.updatedAt || null,
              statusType: p.statusType || prev.statusType || null,
              label: p.driverStatus || prev.label || null,
            });
            applyFiltersAndRender(key);
          } catch {}
        });

        return true;
      } catch {
        return false;
      }
    }

    function startPollingFallback() {
      clearInterval(statusPollTimer);
      statusPollTimer = setInterval(fetchOnline, STATUS_REFRESH_MS);
    }

    // ===== INIT =====
    setInterval(fetchVehicles, VEHICLE_REFRESH_MS);
    document.addEventListener("visibilitychange", () => { if (!document.hidden) fetchOnline(); });

    (async () => {
      await fetchVehicles();
      const ok = wireSSE();
      if (!ok) startPollingFallback(); else fetchOnline();
      adjustStickyOffset();
    })();
  </script>
</body>
</html>
